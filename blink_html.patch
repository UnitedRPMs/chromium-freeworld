diff --git a/third_party/blink/renderer/core/exported/web_form_control_element.cc b/third_party/blink/renderer/core/exported/web_form_control_element.cc
index 093c04b0..07d35bb 100644
--- a/third_party/blink/renderer/core/exported/web_form_control_element.cc
+++ b/third_party/blink/renderer/core/exported/web_form_control_element.cc
@@ -117,11 +117,15 @@
 
 void WebFormControlElement::SetValue(const WebString& value, bool send_events) {
   if (auto* input = ToHTMLInputElementOrNull(*private_)) {
-    input->setValue(
-        value, send_events ? kDispatchInputAndChangeEvent : kDispatchNoEvent);
+    input->setValue(value,
+                    send_events
+                        ? TextFieldEventBehavior::kDispatchInputAndChangeEvent
+                        : TextFieldEventBehavior::kDispatchNoEvent);
   } else if (auto* textarea = ToHTMLTextAreaElementOrNull(*private_)) {
     textarea->setValue(
-        value, send_events ? kDispatchInputAndChangeEvent : kDispatchNoEvent);
+        value, send_events
+                   ? TextFieldEventBehavior::kDispatchInputAndChangeEvent
+                   : TextFieldEventBehavior::kDispatchNoEvent);
   } else if (auto* select = ToHTMLSelectElementOrNull(*private_)) {
     select->setValue(value, send_events);
   }
diff --git a/third_party/blink/renderer/core/exported/web_input_element.cc b/third_party/blink/renderer/core/exported/web_input_element.cc
index 33b5919..a015a80 100644
--- a/third_party/blink/renderer/core/exported/web_input_element.cc
+++ b/third_party/blink/renderer/core/exported/web_input_element.cc
@@ -105,8 +105,9 @@
 
 void WebInputElement::SetChecked(bool now_checked, bool send_events) {
   Unwrap<HTMLInputElement>()->setChecked(
-      now_checked,
-      send_events ? kDispatchInputAndChangeEvent : kDispatchNoEvent);
+      now_checked, send_events
+                       ? TextFieldEventBehavior::kDispatchInputAndChangeEvent
+                       : TextFieldEventBehavior::kDispatchNoEvent);
 }
 
 bool WebInputElement::IsChecked() const {
diff --git a/third_party/blink/renderer/core/html/forms/checkbox_input_type.cc b/third_party/blink/renderer/core/html/forms/checkbox_input_type.cc
index 3951c51..d8967d6 100644
--- a/third_party/blink/renderer/core/html/forms/checkbox_input_type.cc
+++ b/third_party/blink/renderer/core/html/forms/checkbox_input_type.cc
@@ -74,7 +74,8 @@
   if (state->indeterminate)
     GetElement().setIndeterminate(false);
 
-  GetElement().setChecked(!state->checked, kDispatchChangeEvent);
+  GetElement().setChecked(!state->checked,
+                          TextFieldEventBehavior::kDispatchChangeEvent);
   is_in_click_handler_ = true;
   return state;
 }
diff --git a/third_party/blink/renderer/core/html/forms/chooser_only_temporal_input_type_view.cc b/third_party/blink/renderer/core/html/forms/chooser_only_temporal_input_type_view.cc
index f89a5d4..74e5864 100644
--- a/third_party/blink/renderer/core/html/forms/chooser_only_temporal_input_type_view.cc
+++ b/third_party/blink/renderer/core/html/forms/chooser_only_temporal_input_type_view.cc
@@ -131,16 +131,20 @@
 }
 
 void ChooserOnlyTemporalInputTypeView::DidChooseValue(const String& value) {
-  GetElement().setValue(value, kDispatchInputAndChangeEvent);
+  GetElement().setValue(value,
+                        TextFieldEventBehavior::kDispatchInputAndChangeEvent);
 }
 
 void ChooserOnlyTemporalInputTypeView::DidChooseValue(double value) {
   DCHECK(std::isfinite(value) || std::isnan(value));
-  if (std::isnan(value))
-    GetElement().setValue(g_empty_string, kDispatchInputAndChangeEvent);
-  else
-    GetElement().setValueAsNumber(value, ASSERT_NO_EXCEPTION,
-                                  kDispatchInputAndChangeEvent);
+  if (std::isnan(value)) {
+    GetElement().setValue(g_empty_string,
+                          TextFieldEventBehavior::kDispatchInputAndChangeEvent);
+  } else {
+    GetElement().setValueAsNumber(
+        value, ASSERT_NO_EXCEPTION,
+        TextFieldEventBehavior::kDispatchInputAndChangeEvent);
+  }
 }
 
 void ChooserOnlyTemporalInputTypeView::DidEndChooser() {
diff --git a/third_party/blink/renderer/core/html/forms/date_time_numeric_field_element.cc b/third_party/blink/renderer/core/html/forms/date_time_numeric_field_element.cc
index 7c75952..52402eb 100644
--- a/third_party/blink/renderer/core/html/forms/date_time_numeric_field_element.cc
+++ b/third_party/blink/renderer/core/html/forms/date_time_numeric_field_element.cc
@@ -95,10 +95,10 @@
 void DateTimeNumericFieldElement::SetFocused(bool value,
                                              WebFocusType focus_type) {
   if (!value) {
-    int value = TypeAheadValue();
+    int type_ahead_value = TypeAheadValue();
     type_ahead_buffer_.Clear();
-    if (value >= 0)
-      SetValueAsInteger(value, kDispatchEvent);
+    if (type_ahead_value >= 0)
+      SetValueAsInteger(type_ahead_value, kDispatchEvent);
   }
   DateTimeFieldElement::SetFocused(value, focus_type);
 }
diff --git a/third_party/blink/renderer/core/html/forms/html_input_element.cc b/third_party/blink/renderer/core/html/forms/html_input_element.cc
index f9e6de1..2b6b90e 100644
--- a/third_party/blink/renderer/core/html/forms/html_input_element.cc
+++ b/third_party/blink/renderer/core/html/forms/html_input_element.cc
@@ -997,7 +997,8 @@
   // unchecked to match other browsers. DOM is not a useful standard for this
   // because it says only to fire change events at "lose focus" time, which is
   // definitely wrong in practice for these types of elements.
-  if (event_behavior == kDispatchInputAndChangeEvent && isConnected() &&
+  if (event_behavior == TextFieldEventBehavior::kDispatchInputAndChangeEvent &&
+      isConnected() &&
       input_type_->ShouldSendChangeEventAfterCheckedChanged()) {
     DispatchInputEvent();
   }
@@ -1069,7 +1070,7 @@
 
 void HTMLInputElement::SetValueForUser(const String& value) {
   // Call setValue and make it send a change event.
-  setValue(value, kDispatchChangeEvent);
+  setValue(value, TextFieldEventBehavior::kDispatchChangeEvent);
 }
 
 void HTMLInputElement::SetSuggestedValue(const String& value) {
diff --git a/third_party/blink/renderer/core/html/forms/html_input_element.h b/third_party/blink/renderer/core/html/forms/html_input_element.h
index ddcb54e..c0e9b82 100644
--- a/third_party/blink/renderer/core/html/forms/html_input_element.h
+++ b/third_party/blink/renderer/core/html/forms/html_input_element.h
@@ -116,7 +116,9 @@
   bool HasBeenPasswordField() const;
 
   bool checked() const;
-  void setChecked(bool, TextFieldEventBehavior = kDispatchNoEvent);
+  void setChecked(
+      bool,
+      TextFieldEventBehavior = TextFieldEventBehavior::kDispatchNoEvent);
   void DispatchChangeEventIfNeeded();
   void DispatchInputAndChangeEventIfNeeded();
 
@@ -135,13 +137,15 @@
   void setType(const AtomicString&);
 
   String value() const override;
-  void setValue(const String&,
-                ExceptionState&,
-                TextFieldEventBehavior = kDispatchNoEvent);
-  void setValue(const String&,
-                TextFieldEventBehavior = kDispatchNoEvent,
-                TextControlSetValueSelection =
-                    TextControlSetValueSelection::kSetSelectionToEnd) override;
+  void setValue(
+      const String&,
+      ExceptionState&,
+      TextFieldEventBehavior = TextFieldEventBehavior::kDispatchNoEvent);
+  void setValue(
+      const String&,
+      TextFieldEventBehavior = TextFieldEventBehavior::kDispatchNoEvent,
+      TextControlSetValueSelection =
+          TextControlSetValueSelection::kSetSelectionToEnd) override;
   void SetValueForUser(const String&);
   // Update the value, and clear hasDirtyValue() flag.
   void SetNonDirtyValue(const String&);
@@ -163,9 +167,10 @@
   void setValueAsDate(double, bool is_null, ExceptionState&);
 
   double valueAsNumber() const;
-  void setValueAsNumber(double,
-                        ExceptionState&,
-                        TextFieldEventBehavior = kDispatchNoEvent);
+  void setValueAsNumber(
+      double,
+      ExceptionState&,
+      TextFieldEventBehavior = TextFieldEventBehavior::kDispatchNoEvent);
 
   String ValueOrDefaultLabel() const;
 
diff --git a/third_party/blink/renderer/core/html/forms/html_option_element.cc b/third_party/blink/renderer/core/html/forms/html_option_element.cc
index 7ddbf5b1..a109126 100644
--- a/third_party/blink/renderer/core/html/forms/html_option_element.cc
+++ b/third_party/blink/renderer/core/html/forms/html_option_element.cc
@@ -345,7 +345,8 @@
     if (!parentNode() || IsHTMLOptGroupElement(*parentNode()))
       select->OptionRemoved(*this);
   } else if (IsHTMLOptGroupElement(insertion_point)) {
-    if (auto* select = ToHTMLSelectElementOrNull(insertion_point.parentNode()))
+    select = ToHTMLSelectElementOrNull(insertion_point.parentNode());
+    if (select)
       select->OptionRemoved(*this);
   }
   HTMLElement::RemovedFrom(insertion_point);
diff --git a/third_party/blink/renderer/core/html/forms/html_text_area_element.cc b/third_party/blink/renderer/core/html/forms/html_text_area_element.cc
index 5fd9bc3..ae617bb 100644
--- a/third_party/blink/renderer/core/html/forms/html_text_area_element.cc
+++ b/third_party/blink/renderer/core/html/forms/html_text_area_element.cc
@@ -386,7 +386,7 @@
 }
 
 void HTMLTextAreaElement::SetNonDirtyValue(const String& value) {
-  SetValueCommon(value, kDispatchNoEvent,
+  SetValueCommon(value, TextFieldEventBehavior::kDispatchNoEvent,
                  TextControlSetValueSelection::kSetSelectionToEnd);
   is_dirty_ = false;
 }
@@ -410,11 +410,11 @@
   if (normalized_value == value())
     return;
 
-  if (event_behavior != kDispatchNoEvent)
+  if (event_behavior != TextFieldEventBehavior::kDispatchNoEvent)
     SetValueBeforeFirstUserEditIfNotSet();
   value_ = normalized_value;
   SetInnerEditorValue(value_);
-  if (event_behavior == kDispatchNoEvent)
+  if (event_behavior == TextFieldEventBehavior::kDispatchNoEvent)
     SetLastChangeWasNotUserEdit();
   else
     CheckIfValueWasReverted(value_);
@@ -432,16 +432,16 @@
 
   NotifyFormStateChanged();
   switch (event_behavior) {
-    case kDispatchChangeEvent:
+    case TextFieldEventBehavior::kDispatchChangeEvent:
       DispatchFormControlChangeEvent();
       break;
 
-    case kDispatchInputAndChangeEvent:
+    case TextFieldEventBehavior::kDispatchInputAndChangeEvent:
       DispatchInputEvent();
       DispatchFormControlChangeEvent();
       break;
 
-    case kDispatchNoEvent:
+    case TextFieldEventBehavior::kDispatchNoEvent:
       break;
   }
 }
@@ -631,7 +631,8 @@
     const Element& source,
     CloneChildrenFlag flag) {
   const HTMLTextAreaElement& source_element = ToHTMLTextAreaElement(source);
-  SetValueCommon(source_element.value(), kDispatchNoEvent,
+  SetValueCommon(source_element.value(),
+                 TextFieldEventBehavior::kDispatchNoEvent,
                  TextControlSetValueSelection::kSetSelectionToEnd);
   is_dirty_ = source_element.is_dirty_;
   TextControlElement::CloneNonAttributePropertiesFrom(source, flag);
diff --git a/third_party/blink/renderer/core/html/forms/html_text_area_element.h b/third_party/blink/renderer/core/html/forms/html_text_area_element.h
index 9ae4e6f..ac577e8 100644
--- a/third_party/blink/renderer/core/html/forms/html_text_area_element.h
+++ b/third_party/blink/renderer/core/html/forms/html_text_area_element.h
@@ -46,10 +46,11 @@
   bool ShouldWrapText() const { return wrap_ != kNoWrap; }
 
   String value() const override;
-  void setValue(const String&,
-                TextFieldEventBehavior = kDispatchNoEvent,
-                TextControlSetValueSelection =
-                    TextControlSetValueSelection::kSetSelectionToEnd) override;
+  void setValue(
+      const String&,
+      TextFieldEventBehavior = TextFieldEventBehavior::kDispatchNoEvent,
+      TextControlSetValueSelection =
+          TextControlSetValueSelection::kSetSelectionToEnd) override;
   String defaultValue() const;
   void setDefaultValue(const String&);
   int textLength() const { return value().length(); }
diff --git a/third_party/blink/renderer/core/html/forms/input_type.cc b/third_party/blink/renderer/core/html/forms/input_type.cc
index 5512651..a60dbe4 100644
--- a/third_party/blink/renderer/core/html/forms/input_type.cc
+++ b/third_party/blink/renderer/core/html/forms/input_type.cc
@@ -520,21 +520,21 @@
   // TextFieldInputType. That is to say, type=color, type=range, and temporal
   // input types.
   DCHECK_EQ(GetValueMode(), ValueMode::kValue);
-  if (event_behavior == kDispatchNoEvent)
+  if (event_behavior == TextFieldEventBehavior::kDispatchNoEvent)
     GetElement().SetNonAttributeValue(sanitized_value);
   else
     GetElement().SetNonAttributeValueByUserEdit(sanitized_value);
   if (!value_changed)
     return;
   switch (event_behavior) {
-    case kDispatchChangeEvent:
+    case TextFieldEventBehavior::kDispatchChangeEvent:
       GetElement().DispatchFormControlChangeEvent();
       break;
-    case kDispatchInputAndChangeEvent:
+    case TextFieldEventBehavior::kDispatchInputAndChangeEvent:
       GetElement().DispatchInputEvent();
       GetElement().DispatchFormControlChangeEvent();
       break;
-    case kDispatchNoEvent:
+    case TextFieldEventBehavior::kDispatchNoEvent:
       break;
   }
 }
@@ -775,7 +775,8 @@
     return;
   }
   const Decimal current = ParseToNumber(GetElement().value(), 0);
-  ApplyStep(current, n, kRejectAny, kDispatchNoEvent, exception_state);
+  ApplyStep(current, n, kRejectAny, TextFieldEventBehavior::kDispatchNoEvent,
+            exception_state);
 }
 
 void InputType::StepUpFromLayoutObject(int n) {
@@ -845,18 +846,21 @@
       current = step_range.Minimum() - next_diff;
     if (current > step_range.Maximum() - next_diff)
       current = step_range.Maximum() - next_diff;
-    SetValueAsDecimal(current, kDispatchNoEvent, IGNORE_EXCEPTION_FOR_TESTING);
+    SetValueAsDecimal(current, TextFieldEventBehavior::kDispatchNoEvent,
+                      IGNORE_EXCEPTION_FOR_TESTING);
   }
   if ((sign > 0 && current < step_range.Minimum()) ||
       (sign < 0 && current > step_range.Maximum())) {
     SetValueAsDecimal(sign > 0 ? step_range.Minimum() : step_range.Maximum(),
-                      kDispatchChangeEvent, IGNORE_EXCEPTION_FOR_TESTING);
+                      TextFieldEventBehavior::kDispatchChangeEvent,
+                      IGNORE_EXCEPTION_FOR_TESTING);
     return;
   }
   if ((sign > 0 && current >= step_range.Maximum()) ||
       (sign < 0 && current <= step_range.Minimum()))
     return;
-  ApplyStep(current, n, kAnyIsDefaultStep, kDispatchChangeEvent,
+  ApplyStep(current, n, kAnyIsDefaultStep,
+            TextFieldEventBehavior::kDispatchChangeEvent,
             IGNORE_EXCEPTION_FOR_TESTING);
 }
 
diff --git a/third_party/blink/renderer/core/html/forms/multiple_fields_temporal_input_type_view.cc b/third_party/blink/renderer/core/html/forms/multiple_fields_temporal_input_type_view.cc
index 1588d0f5..fd2ac78 100644
--- a/third_party/blink/renderer/core/html/forms/multiple_fields_temporal_input_type_view.cc
+++ b/third_party/blink/renderer/core/html/forms/multiple_fields_temporal_input_type_view.cc
@@ -271,7 +271,8 @@
 void MultipleFieldsTemporalInputTypeView::PickerIndicatorChooseValue(
     const String& value) {
   if (GetElement().IsValidValue(value)) {
-    GetElement().setValue(value, kDispatchInputAndChangeEvent);
+    GetElement().setValue(value,
+                          TextFieldEventBehavior::kDispatchInputAndChangeEvent);
     return;
   }
 
@@ -289,11 +290,14 @@
 void MultipleFieldsTemporalInputTypeView::PickerIndicatorChooseValue(
     double value) {
   DCHECK(std::isfinite(value) || std::isnan(value));
-  if (std::isnan(value))
-    GetElement().setValue(g_empty_string, kDispatchInputAndChangeEvent);
-  else
-    GetElement().setValueAsNumber(value, ASSERT_NO_EXCEPTION,
-                                  kDispatchInputAndChangeEvent);
+  if (std::isnan(value)) {
+    GetElement().setValue(g_empty_string,
+                          TextFieldEventBehavior::kDispatchInputAndChangeEvent);
+  } else {
+    GetElement().setValueAsNumber(
+        value, ASSERT_NO_EXCEPTION,
+        TextFieldEventBehavior::kDispatchInputAndChangeEvent);
+  }
 }
 
 Element& MultipleFieldsTemporalInputTypeView::PickerOwnerElement() const {
@@ -618,7 +622,8 @@
 }
 
 void MultipleFieldsTemporalInputTypeView::ClearValue() {
-  GetElement().setValue("", kDispatchInputAndChangeEvent);
+  GetElement().setValue("",
+                        TextFieldEventBehavior::kDispatchInputAndChangeEvent);
   GetElement().UpdateClearButtonVisibility();
 }
 
diff --git a/third_party/blink/renderer/core/html/forms/radio_input_type.cc b/third_party/blink/renderer/core/html/forms/radio_input_type.cc
index b9577f9..f2653bd1 100644
--- a/third_party/blink/renderer/core/html/forms/radio_input_type.cc
+++ b/third_party/blink/renderer/core/html/forms/radio_input_type.cc
@@ -191,7 +191,7 @@
 
   state->checked = GetElement().checked();
   state->checked_radio_button = GetElement().CheckedRadioButtonForGroup();
-  GetElement().setChecked(true, kDispatchChangeEvent);
+  GetElement().setChecked(true, TextFieldEventBehavior::kDispatchChangeEvent);
   is_in_click_handler_ = true;
   return state;
 }
diff --git a/third_party/blink/renderer/core/html/forms/range_input_type.cc b/third_party/blink/renderer/core/html/forms/range_input_type.cc
index bd06a76..98d9b54 100644
--- a/third_party/blink/renderer/core/html/forms/range_input_type.cc
+++ b/third_party/blink/renderer/core/html/forms/range_input_type.cc
@@ -228,7 +228,8 @@
 
   if (new_value != current) {
     EventQueueScope scope;
-    TextFieldEventBehavior event_behavior = kDispatchInputAndChangeEvent;
+    TextFieldEventBehavior event_behavior =
+        TextFieldEventBehavior::kDispatchInputAndChangeEvent;
     SetValueAsDecimal(new_value, event_behavior, IGNORE_EXCEPTION_FOR_TESTING);
 
     if (AXObjectCache* cache =
diff --git a/third_party/blink/renderer/core/html/forms/text_control_element.cc b/third_party/blink/renderer/core/html/forms/text_control_element.cc
index 8f67a1d..1648260 100644
--- a/third_party/blink/renderer/core/html/forms/text_control_element.cc
+++ b/third_party/blink/renderer/core/html/forms/text_control_element.cc
@@ -975,7 +975,8 @@
 void TextControlElement::SetAutofillValue(const String& value) {
   // Set the value trimmed to the max length of the field and dispatch the input
   // and change events.
-  setValue(value.Substring(0, maxLength()), kDispatchInputAndChangeEvent);
+  setValue(value.Substring(0, maxLength()),
+           TextFieldEventBehavior::kDispatchInputAndChangeEvent);
 }
 
 // TODO(crbug.com/772433): Create and use a new suggested-value element instead.
diff --git a/third_party/blink/renderer/core/html/forms/text_control_element.h b/third_party/blink/renderer/core/html/forms/text_control_element.h
index d20dbfb..cee5e95 100644
--- a/third_party/blink/renderer/core/html/forms/text_control_element.h
+++ b/third_party/blink/renderer/core/html/forms/text_control_element.h
@@ -42,7 +42,7 @@
   kSelectionHasForwardDirection,
   kSelectionHasBackwardDirection
 };
-enum TextFieldEventBehavior {
+enum class TextFieldEventBehavior {
   kDispatchNoEvent,
   kDispatchChangeEvent,
   kDispatchInputAndChangeEvent
@@ -123,7 +123,7 @@
   virtual String value() const = 0;
   virtual void setValue(
       const String&,
-      TextFieldEventBehavior = kDispatchNoEvent,
+      TextFieldEventBehavior = TextFieldEventBehavior::kDispatchNoEvent,
       TextControlSetValueSelection =
           TextControlSetValueSelection::kSetSelectionToEnd) = 0;
 
diff --git a/third_party/blink/renderer/core/html/forms/text_field_input_type.cc b/third_party/blink/renderer/core/html/forms/text_field_input_type.cc
index 3b5749f..73b0dc5 100644
--- a/third_party/blink/renderer/core/html/forms/text_field_input_type.cc
+++ b/third_party/blink/renderer/core/html/forms/text_field_input_type.cc
@@ -153,7 +153,7 @@
                                   TextControlSetValueSelection selection) {
   // We don't use InputType::setValue.  TextFieldInputType dispatches events
   // different way from InputType::setValue.
-  if (event_behavior == kDispatchNoEvent)
+  if (event_behavior == TextFieldEventBehavior::kDispatchNoEvent)
     GetElement().SetNonAttributeValue(sanitized_value);
   else
     GetElement().SetNonAttributeValueByUserEdit(sanitized_value);
@@ -173,7 +173,7 @@
   }
 
   switch (event_behavior) {
-    case kDispatchChangeEvent:
+    case TextFieldEventBehavior::kDispatchChangeEvent:
       // If the user is still editing this field, dispatch an input event rather
       // than a change event.  The change event will be dispatched when editing
       // finishes.
@@ -183,13 +183,13 @@
         GetElement().DispatchFormControlChangeEvent();
       break;
 
-    case kDispatchInputAndChangeEvent: {
+    case TextFieldEventBehavior::kDispatchInputAndChangeEvent: {
       GetElement().DispatchInputEvent();
       GetElement().DispatchFormControlChangeEvent();
       break;
     }
 
-    case kDispatchNoEvent:
+    case TextFieldEventBehavior::kDispatchNoEvent:
       break;
   }
 }
diff --git a/third_party/blink/renderer/core/html/html_hr_element.cc b/third_party/blink/renderer/core/html/html_hr_element.cc
index 9ac4214..f959326 100644
--- a/third_party/blink/renderer/core/html/html_hr_element.cc
+++ b/third_party/blink/renderer/core/html/html_hr_element.cc
@@ -135,7 +135,8 @@
       select->HrInsertedOrRemoved(*this);
   } else if (IsHTMLOptGroupElement(insertion_point)) {
     Node* parent = insertion_point.parentNode();
-    if (auto* select = ToHTMLSelectElementOrNull(parent))
+    select = ToHTMLSelectElementOrNull(parent);
+    if (select)
       select->HrInsertedOrRemoved(*this);
   }
   HTMLElement::RemovedFrom(insertion_point);
diff --git a/third_party/blink/renderer/core/html/html_slot_element.cc b/third_party/blink/renderer/core/html/html_slot_element.cc
index 35726eb..e33da81 100644
--- a/third_party/blink/renderer/core/html/html_slot_element.cc
+++ b/third_party/blink/renderer/core/html/html_slot_element.cc
@@ -122,16 +122,17 @@
     for (auto& child : NodeTraversal::ChildrenOf(slot)) {
       if (!child.IsSlotable())
         continue;
-      if (auto* slot = ToHTMLSlotElementIfSupportsAssignmentOrNull(child))
-        nodes.AppendVector(CollectFlattenedAssignedNodes(*slot));
+      if (auto* child_slot = ToHTMLSlotElementIfSupportsAssignmentOrNull(child))
+        nodes.AppendVector(CollectFlattenedAssignedNodes(*child_slot));
       else
         nodes.push_back(child);
     }
   } else {
     for (auto& node : assigned_nodes) {
       DCHECK(node->IsSlotable());
-      if (auto* slot = ToHTMLSlotElementIfSupportsAssignmentOrNull(*node))
-        nodes.AppendVector(CollectFlattenedAssignedNodes(*slot));
+      if (auto* assigned_node_slot =
+              ToHTMLSlotElementIfSupportsAssignmentOrNull(*node))
+        nodes.AppendVector(CollectFlattenedAssignedNodes(*assigned_node_slot));
       else
         nodes.push_back(node);
     }
diff --git a/third_party/blink/renderer/core/html/parser/html_tree_builder.cc b/third_party/blink/renderer/core/html/parser/html_tree_builder.cc
index 960c2da..562be2e 100644
--- a/third_party/blink/renderer/core/html/parser/html_tree_builder.cc
+++ b/third_party/blink/renderer/core/html/parser/html_tree_builder.cc
@@ -1461,7 +1461,7 @@
     HTMLElementStack::ElementRecord* next_node = node->Next();
     HTMLElementStack::ElementRecord* last_node = furthest_block;
     // 9.1, 9.2, 9.3 and 9.11 are covered by the for() loop.
-    for (int i = 0; i < kInnerIterationLimit; ++i) {
+    for (int j = 0; j < kInnerIterationLimit; ++j) {
       // 9.4
       node = next_node;
       DCHECK(node);
diff --git a/third_party/blink/renderer/core/html/parser/text_resource_decoder.cc b/third_party/blink/renderer/core/html/parser/text_resource_decoder.cc
index d5c6c8e..b9a380e 100644
--- a/third_party/blink/renderer/core/html/parser/text_resource_decoder.cc
+++ b/third_party/blink/renderer/core/html/parser/text_resource_decoder.cc
@@ -329,11 +329,13 @@
       return false;
     // No need for +1, because we have an extra "?" to lose at the end of XML
     // declaration.
-    int len = 0;
-    int pos =
-        FindXMLEncoding(ptr, static_cast<int>(xml_declaration_end - ptr), len);
-    if (pos != -1)
-      SetEncoding(FindTextEncoding(ptr + pos, len), kEncodingFromXMLHeader);
+    int encoding_length = 0;
+    int encoding_pos = FindXMLEncoding(
+        ptr, static_cast<int>(xml_declaration_end - ptr), encoding_length);
+    if (encoding_pos != -1) {
+      SetEncoding(FindTextEncoding(ptr + encoding_pos, encoding_length),
+                  kEncodingFromXMLHeader);
+    }
     // continue looking for a charset - it may be specified in an HTTP-Equiv
     // meta
   } else if (BytesEqual(ptr, '<', 0, '?', 0, 'x', 0)) {
diff --git a/third_party/blink/renderer/core/html/track/vtt/vtt_cue.cc b/third_party/blink/renderer/core/html/track/vtt/vtt_cue.cc
index 88f5e5e..95b4dd3 100644
--- a/third_party/blink/renderer/core/html/track/vtt/vtt_cue.cc
+++ b/third_party/blink/renderer/core/html/track/vtt/vtt_cue.cc
@@ -767,7 +767,6 @@
 
   for (Node& child : NodeTraversal::DescendantsOf(*display_tree_)) {
     if (child.nodeName() == timestamp_tag) {
-      double current_timestamp;
       bool check =
           VTTParser::CollectTimeStamp(child.nodeValue(), current_timestamp);
       DCHECK(check);
diff --git a/third_party/blink/renderer/core/testing/internals.cc b/third_party/blink/renderer/core/testing/internals.cc
index 8be6757..446e343 100644
--- a/third_party/blink/renderer/core/testing/internals.cc
+++ b/third_party/blink/renderer/core/testing/internals.cc
@@ -1366,7 +1366,7 @@
   }
 
   if (auto* select = ToHTMLSelectElementOrNull(*element))
-    select->setValue(value, kDispatchInputAndChangeEvent);
+    select->setValue(value, true /* send_events */);
 
   ToHTMLFormControlElement(element)->SetAutofillState(
       blink::WebAutofillState::kAutofilled);
diff --git a/third_party/blink/renderer/modules/accessibility/ax_layout_object.cc b/third_party/blink/renderer/modules/accessibility/ax_layout_object.cc
index 102adea..ad546bef 100644
--- a/third_party/blink/renderer/modules/accessibility/ax_layout_object.cc
+++ b/third_party/blink/renderer/modules/accessibility/ax_layout_object.cc
@@ -2547,13 +2547,13 @@
   LayoutBoxModelObject* layout_object = ToLayoutBoxModelObject(layout_object_);
   if (layout_object->IsTextField() && IsHTMLInputElement(*GetNode())) {
     ToHTMLInputElement(*GetNode())
-        .setValue(string, kDispatchInputAndChangeEvent);
+        .setValue(string, TextFieldEventBehavior::kDispatchInputAndChangeEvent);
     return true;
   }
 
   if (layout_object->IsTextArea() && IsHTMLTextAreaElement(*GetNode())) {
     ToHTMLTextAreaElement(*GetNode())
-        .setValue(string, kDispatchInputAndChangeEvent);
+        .setValue(string, TextFieldEventBehavior::kDispatchInputAndChangeEvent);
     return true;
   }
 
diff --git a/third_party/blink/renderer/modules/accessibility/ax_slider.cc b/third_party/blink/renderer/modules/accessibility/ax_slider.cc
index 67c1070..efa16d4 100644
--- a/third_party/blink/renderer/modules/accessibility/ax_slider.cc
+++ b/third_party/blink/renderer/modules/accessibility/ax_slider.cc
@@ -114,7 +114,7 @@
   if (input->value() == value)
     return false;
 
-  input->setValue(value, kDispatchInputAndChangeEvent);
+  input->setValue(value, TextFieldEventBehavior::kDispatchInputAndChangeEvent);
 
   // Fire change event manually, as LayoutSlider::setValueForPosition does.
   input->DispatchFormControlChangeEvent();
